\section{Overview}
\label{sec:overview}

In this section, we describe the high-level architecture of \project{}, our threat model, and the key design challenges.

\subsection{Architecture and Workflow}
\label{sec:arch}
The \project{} architecture consists of the following components, as depicted in \autoref{fig:secndp-arch_overview}: \textit{client}, \textit{trusted monitor}, \textit{host} and \textit{storage system}. 
Client is a piece of software that provides a data query interface that is used by different parties, including data producers and consumers. This interface offers the ability to require the enforcement of specific security policies when submitting queries to \project{}'s query processing infrastructure. The client interacts with the query processing infrastructure that in turn consists of two central components responsible for query processing---host and storage system---and a supervising component---the monitor. The host features an untrusted OS and a trusted host engine. The storage system includes the (trusted) storage engine, which is executed in a processing unit either within a storage device, or a storage server, and the (untrusted) storage medium where data is stored. The storage engine handles processing to be done near the data.
The trusted monitor %receives the client request and <<< the host receives the query not the trusted monitor, see figure 2
coordinates with the host engine and storage system to execute the computation or data operations in a policy compliant manner. The trusted monitor ensures this by attesting both the host and storage engine. The security of attestation is rooted on trusted boot and several other hardware-backed mechanisms~\cite{ananti-hasp-2013}.


\begin{figure}[t]
	\centering
	\includegraphics[width=\linewidth]{figures/high-level-arch.pdf}
    \vspace{-1mm}
	\caption{\small Architecture of \project{} (TCB shown in green)}
	\label{fig:secndp-arch_overview} 
	\vspace{-2mm}
\end{figure}

To illustrate the workflow of \project{}, consider the scenario depicted in \autoref{fig:secndp-arch_overview}. It represents two entities $\mathcal{A}$ and $\mathcal{B}$ that collaborate  with each other in processing data from a customer ($\mathcal{C}$).
Both these entities play the GDPR role of controllers as they offer to customers some specific service, e.g., $\mathcal{A}$ is an airline company and $\mathcal{B}$ is a hotel chain. In GDPR, customers retain ownership of their data. In this scenario, $\mathcal{A}$ collects data from its customers, e.g., when booking a flight, and it is willing to allow $\mathcal{B}$ to issue certain external queries, e.g., to consult the arrival time of a particular customer. \project{} provides a secure storage infrastructure that allows $\mathcal{A}$ to share data with $\mathcal{B}$ in a secure and policy-compliant manner. In this sense, $\mathcal{A}$ and $\mathcal{B}$ act as data producer and consumer, respectively. \project{} is deployed by a cloud provider who plays the role of GDPR data processor, and it allows both $\mathcal{A}$ and $\mathcal{B}$ to submit different queries: $\mathcal{A}$ has full r/w access to the data being able to insert, update, or delete records; $\mathcal{B}$ is allowed only to perform certain read-only queries. The entire query processing workflow is determined by the compliance policies attached to each query. These policies can be specified so as to prevent violation of regulations such as the GDPR. Upon request, \project{} allows a designated regulatory authority ($\mathcal{D}$) to obtain proof of compliance by accessing an audit trail from the trusted monitor.

More specifically, the workflow of any given data processing query is as follows. When instructed by $\mathcal{A}$ or $\mathcal{B}$, the client submits the query and an associated user-defined \textit{execution policy} to the host engine over an encrypted TLS channel (step \circled{1}). Upon receiving a client request (i.e., query and corresponding policy), the host requests the assistance of the trusted monitor to verify that the client's request has the right permissions to access the data. This verification is performed by validating the query and the identity of the client against an \textit{access policy} previously specified by the data producer. This access policy is maintained by the trusted monitor and it is set up by the time the data producer initializes the database on \project{}. Before authorizing the execution of the query, the monitor must also check if the host and storage engine satisfy the constraints specified in the client's compliance policy. This is performed in step \circled{2}. If the check succeeds, the query is partitioned in the host engine, and offloaded to storage engine (step \circled{3}). The storage engine accesses users' data on persistent storage, executes the offloaded query and relays the results back to the host in step \circled{4}. The host engine process the filtered out data by executing its query. Then it sends to the client both the query results and proof of compliance with client's security policy (step \circled{5}). In \project{}, both execution policy and access policy are specified in our own declarative policy specification language.
%We have designed our system to provide high query processing performance, strong end-to-end security, and strict policy compliance assurances. Next, we present our building blocks and threat model, and elaborate on the key challenges to attaining our goals.
\if0
The diagram shown in \autoref{fig:secndp-arch_overview} represents an high-level view of the \project{} architecture.
The client is a user of the \project{} system.
They hold security sensitive information (e.g., a database) on a remotely hosted storage device, and submit queries to a trusted remote host, the Storage System, which they are connected to and trust.
The Storage System upon receiving queries splits them. 
Part of the original query executes in the Storage System, and another executes in the \project{} Backend.
This split is a performance informed procedure, and guarantees high performance query execution.
The Host Engine also operates in a shielded execution environment. 
In addition to executing queries issued by the Storage System, the Host Engine is the entity that directly accesses data stored in the storage medium.
To enable bidirectional trust between the Storage System and Backend, an attestation service executed in the \project{}~Controller acts as the \project{}~Root-of-Trust.
The \project{}~Controller authenticates both the Storage System and Backend, and provides proof to both, of each other's valid state.
Steps~(1) are authentication steps to the \project{} Attestation Service, and provide assurance of each entity correct instantiation.
Steps~(2) are secondary authentication between each additionaly identity: Client, Host Engine, and Storage System.
Steps~(3) are query issuing and execution.
\fi
%\pramod{I think the following sub section is just confusing -- its unnecessarily diluting the focus and opening us to a lot of attacks. We do NOT need to claim a LOT of things. We should just focus on two deployment scenario: device and server. The other models can be a variant of them and we can add a simple sentence to say that...Secondly, i think this should be merged with 2.1 and set the stage up front as early as possible.}
\if0
\myparagraph{Performance}
For better performance the best configuration is (a), due to the system components being connected to the same bus. This allows for the lowest latency in communication between the  components.
\david{It's not entirely obvious to me that (b) could not be better performant, especially due to weaker CPUs on the smart SSDs. I feel that we would need to perform comparative benchmarks, on a real-world deployment to confidently assess this.}

\myparagraph{Scalability}
The solution providing best scalability is (b). 
It requires the least amount of specialized hardware, by not requiring the use of smartSSDs.
Additionally it allows for more hardware resources to be used for NDP, as compared to on-storage configurations (e.g., more memory, more storage, and more processing power).
\david{Some doubts about scalability: using trustzone on a storage server will require the trustzone TEE to be able to handle multi-tenancy, lowering overall security guarantees.}

\myparagraph{Trusted Hardware}
The required trusted hardware is as follows.
For the Storage System Intel's SGX is an appropriate technology, as it provides an both an isolated environment and low privilege environment for running security sensitive applications.
\david{Should we also mention AMD's SEV? we want to provide an abstract view, and the concrete technology is just an implementation detail}
As for the Host Engine, only TrustZone is available on smartSSDs, furthermore, Arm-based storage servers have gained track recently~\cite{} which legitimizes their use as part for \project{}. Alternatively, SGX could be used when using Intel processors for hosting the storage server.
\fi

\subsection{Hardware Building Blocks}
\label{sec:buildingblocks}
%End-to-end security and policy compliance in \project{} is achieved by leveraging pre-existing hardware mechanisms:
\myparagraph{Trusted execution environments} \project{} requires TEE hardware technology for securing the execution of query processing both at the host and storage systems. We envision the host system to be an x86 machine. Thus, confidential execution will be supported by SGX enclaves~\cite{intelsgx}.
As for the storage system, \project{} benefits from bringing query execution to processing units resident as close as possible to the storage medium ---where data is located.
Given emerging computational storage devices are based on ARM CPUs, and storage servers increasingly adopt or include ARM CPUs ($\S$~\ref{sec:ndp_arch}), the storage system's confidential execution relies primarily on ARM TrustZone~\cite{armtz}.

\myparagraph{Trusted boot} \project{} relies on trusted boot for establishing its root of trust~\cite{ias,atf}. Trusted boot validates the integrity and authenticity of the software that implements the host engine and storage system. In SGX, although the boot process is not part of the TCB, loading and initializing an enclave includes the process of computing a hash of the guest application code which allows remote parties to validate the correct initialization of an enclave. In TrustZone, trusted boot allows for authentication of each world's images, thus allowing for the system to be brought to a known secure state.

\myparagraph{Remote attestation} \project{} implements security protocols that allow a remote client to obtain hard cryptographic evidence about the correct deployment of all its components on a given cloud infrastructure. In SGX, remote attestation is supported by two hardware mechanisms which compute a hash of the enclave code upon initialization, and issue digital signatures of that hash using on-chip keys certified by Intel. TrustZone does not provide built-in remote attestation primitives apart from an on-chip key provided by the device manufacturer. In this case, we assume that remote attestation primitives are implemented by the device firmware running in the secure world.

\myparagraph{Secure storage on the storage medium} \project{} also relies on specific hardware primitives to implement secure storage on the storage medium. In TrustZone-based systems, it is common for flash memories to be used as storage medium. These flash memories, are often imbued with a partition which can only be access by an authenticated agent (i.e., a TEE) \cite{emmcrpmb, opteesecurestorage}. This partition is a replay protected memory block (RPMB) and can then be used to hold security sensitive data. Additionally, TAs can store larger amounts of data by storing data in an encrypted form in the normal world file system~\cite{opteesecurestorage}.

\subsection{Security Goals and Threat Model}
\label{overview:threat-model}
We aim at designing \project{} to provide end-to-end security for all data queries submitted and processed by our system, especially by host and storage system. Essentially, this protection entails preserving the confidentially, integrity, and freshness of all data at runtime (i.e., at processing time), at rest (i.e., on persistent storage), and in transit (i.e., exchanged over the network). In particular, we aim to defend against an adversary that can launch the following attacks:

\myparagraph{Attacks to volatile state} As shown in \autoref{fig:secndp-arch_overview}, the host engine and the storage engine need to process sensitive query-related data in main memory. We aim to defend against attacks aimed to inspect or tamper with the runtime state of these components. On the host, we consider an attacker with the ability to control the operating system. Targeting an x86 host equipped with SGX, the adversary will be able to access the full memory state, except the memory pages allocated to user-level enclaves; the attacker has no access to the enclave protecting the host engine. %(We assume the trusted monitor runs on an x86 server and can also be secured against similar attacks by harnessing SGX enclaves.) 
On the storage system, the attacker may also attempt to gain control of the storage engine runtime state (i.e., containing query processed data). Assuming that the storage system is deployed on a TrustZone-featured ARM platform and that the firmware (running in secure world) is trusted, the trusted boot mechanism will bring the storage system into a state that the attacker will not be able to control. This guarantee can also be extended to the REE OS (running in the normal world) as long as the REE OS is a secure component (e.g., a hardened kernel) and trusted boot also measures the integrity of the REE OS. Nevertheless, the attacker may attempt to impersonate a trusted device so as to convince the host engine to offload computations to an alternative storage system controlled by the adversary.

%Thus, we trust the REE firmware and its ability to isolate the host-offloaded code from the REE firmware. 

%On the {\emph host engine}, we consider the same threat model as SGX~\cite{baumann2014}, a strong adversary who controls the entire system software, including the device drivers and the operating system, and may have physical access to the system. Such an adversary can read and tamper with code and data of any victim application's process, but not the enclave itself. 

%\noindent On the \emph{storage system}, we trust security primitives including secure boot, attestation, and safe keeping of storage integrity measurements. Additionally Because we assume the storage system to be ARM-based, for the NDP device and NDP sever configurations, we trust secure world software and the runtime running in the normal world.

%\noindent Code offloaded to the storage system is not part of the system's trusted computing base (TCB) thus, storage system security does not depend on its trustworthiness.

\myparagraph{Attacks to persistent state} In \project{}, the persistent state is maintained on untrusted storage medium by the storage system. %Although the attacker cannot access the storage medium if the storage system is booted into a secure and trusted state (as explained above), 
The attacker may attempt to bypass trusted boot by booting the storage system into an OS under its control and then gain unlimited access to the storage medium. At this point, the adversary may attempt to inspect the content of persistent data, or modify persistent data without being detected. In particular, it may attempt to launch rollback attacks in which the data on storage may be reverted to a stale version. Such an attack could result in the suppression of recently committed storage operations. We also consider forking attacks where the adversary can attempt to fork the storage system, by running multiple replicas of it.

\if0 % this is from older version
We consider rollback attacks in which an adversary can replay storage operations to try to, for example, rollback the storage medium to a stale state.
We consider forking attacks where the adversary can attempt to fork the storage system, by running multiple replicas of it. Additionally, an attacker might try to spoof data operations including where data is written to. We do not prevent against data corruption, but we detect any data or message tampering while maintaining secrecy. We consider that tampering protection for the storage medium is provided by the enclosure or the data-center physical infra-structure. Moreover, the storage medium could implement the OPAL standard for encryption \cite{opal}, which improves physical security by transparently encrypting all stored data at the device-level, requiring a secret key (which is provided on system start-up) to operate on it. This promotes defence in depth in that an attacker must obtain two secrets to read the stored data offline, the OPAL key and the Storage System key.
\fi
%\pramod{}\david{}\nuno{OPAL auto encrypts data, I was thinking we always write encrypted data, independently of what is the deployment scenario that we use -- correct? With OPAL we can get double encryption, if needed \textbf{R:} david - You're right! I do believe OPAL is a bit redundant in this case as we are already protecting data at rest by encrypting it.}

\myparagraph{Attacks to communications} An adversary may intercept, inject, or modify messages exchanged between all \project{}'s actors. %It can also duplicate or inject new messages into the network. 
The adversary's goals include: impersonation of legitimate actors, inspection of communications, or tampering with exchanged messages.

%\myparagraph{Client side attacks} Attacks that exploit vulnerabilities in applications, such as SQL injection, and lead to data breaches are recorded correctly into a tamper proof log by \project{}. This process cannot be circumvented by an attacker as we trust the underlying hardware to protect the software responsible for logging(\S~\ref{sec:policylanguage}).

%\pramod{the following paragraph can be killed. or merged in TEEs 2.3}
\myparagraph{Attacks out of scope}
We do not protect against side-channel attacks, such as exploiting cache timing, memory access patterns and speculative execution~\cite{bulck-security-2018, hahnel-atc-2017, xu-ieeesp-2015}. 
We also do not consider denial of service attacks as they are easy to defend with a trusted third party operator controlling the underlying infrastructure~\cite{baumann2014}.
It is also out of scope physical attacks that involve tampering with the SGX or TrustZone hardware. These components are part of our trusted computing base. We also rule out sophisticated physical attacks to host and storage system, e.g., unsoldering SoC/CPU/flash chips. %dies.
Attacks that exploit vulnerabilities in client applications and lead to data breaches through crafted queries, such as SQL injection, are correctly recorded into a tamper proof log by \project{}. This logging process cannot be circumvented by an attacker as we trust the underlying hardware to protect the software responsible for logging(\S~\ref{sec:policylanguage}).
%Simple physical attacks such as snooping the memory bus or the PCIe bus on the hostAn adversary with physical access to the setup can mount snooping attacks on the host memory bus and the PCIe bus.  However, we trust the CPU and storage devices' package.% and assume that the adversary cannot extract secrets or corrupt state within the packages.
%\antonio{Several comments, I let you integrate them, as you may already addressed them. It makes sense that we don't trust the host OS. Therefore, we either need to write directly from the SGX to the storage devices (SSD) or to the network card. Even if, in both cases writing or reading unencrypted, will leave the corrupted OS the possibility to spoof our data and eventually where we are going to write. Therefore, an entire command, including data must be encrypted before leaving the SGX. After leaving the SGX, it can even go via the OS. Thus, we are going to pay for encryption/decryption. In this case we are also protecting from PCIe physical tampering -- correct? However, we need an SSD that is able to identify the concept of channel (OPAL standard for encryption, https://www.delkin.com/blog/encryption-and-security-development-in-solid-state-storage-devices-ssd/), then the channel embodies the idea of encryption/decryption.\\ On the storage node/device you need to pay for encryption/decryption twice for NDP, which considering the security advantage is OK to be paid -- are we going to show that?}

%\myparagraph{Possible reduction in TCB on the storage side}
Due to the limitations of ARM TrustZone, we currently need to consider the entire OS stack and query engine on the storage side as part of our TCB. However, ARM v9~\cite{arm-realm} aims to overcome this limitation, which would allow us to not trust the OS stack anymore.

% \vspace{-4mm}
\subsection{Design Challenges}
\label{subsect:design-challenges}
\input{figures/design-figures}

% \vspace{-3.8mm}
\myparagraph{\#1. Heterogeneous TEE technology} In \project{}, to build our end-to-end security infrastructure, we rely on basic hardware primitives offered by SGX and TrustZone, namely TEE-isolated environments for securing in-memory state, and secure storage primitives for protection on-storage data (see $\S$~\ref{sec:buildingblocks}). However, the TEE primitives implemented by these technologies have important differences. For instance, SGX allows for seamlessly creating user-level enclaves, but they limit the amount of memory that can be allocated by applications and impose considerable performance overheads due to hardware-level memory encryption. On the other hand, TrustZone imposes no strict memory size limits and adds negligible performance overheads, but features a cumbersome protection model, where TEE environments are typically not available for general use by full-blown applications. Bringing together these two technologies while preserving security and performance is not a trivial task in the design of \project{}. A second challenge involves the protection of data at rest. Although SGX and TrustZone provide protection for in-memory state, the mechanisms do not naturally extend to untrusted storage medium. %In our case, \project{}'s storage system requires additional mechanisms for: (i) management of on-storage cryptographic keys, (ii) efficient integrity checking and high-performing encryption/decryption of data blocks, and (iii) data block versioning and rollback-attack mitigation. 
To address both these challenges, we developed a \textit{heterogeneous confidential computing framework} (see $\S$~\ref{subsec:design-sef}).

\if0
\myparagraph{\#1. Heterogenous TEE technology} NDP requires ensuring the preservation of confidentiality, integrity, and freshness of data and computations across heterogeneous protection domains. These domains are enforced by two hardware technologies characterized by specific programming / execution abstractions and by distinct security properties. On the one hand, SGX provides enclaves where the execution state of an application is automatically secured by the hardware. However, SGX enclaves limit the amount of memory that can be allocated by applications.
On the other hand, ARM TrustZone offers an abstraction where trusted applications run inside the secure world. The hardware provides a secure switching mechanism between the normal and secure worlds, %but it offers no native on-chip memory encryption.
while memory is not encrypted but inaccessible from the normal world.
Yet, secure world is not intended to be used by general purpose programs, which if vulnerable could compromise the entire system.
In our case, this heterogeneity introduce the challenge of coping with the disparity between these technologies and providing seamless application state protection for NDP settings. To address this challenge, we developed a \textit{hybrid shielded execution framework} (see $\S$~\ref{subsec:design-sef}).

\myparagraph{\#2: Untrusted storage medium} In addition to securing computation, a secure ndp architecture needs to protect data at rest in the untrusted storage medium by ensuring the persistence of security properties across system reboots, crashes, shutdown events, or migration across machines. 
Although TEE-enabling technology---i.e., Intel SGX or ARM TrustZone---provides protection for in-memory state, the mechanisms do not naturally extend to the untrusted storage medium. 
Some instances of TEE hardware provide basic primitives for stateful-data security such as trusted monotonic counters, which can help defend against rollback attacks. 
However, TEE hardware lacks additional primitives for extending the trust from heterogeneous TEEs to untrusted storage medium. 
In particular, a secure NDP architecture requires specific mechanisms for: (i) cryptographic key management on a single host and across machines, (ii) efficient integrity checking and high-performing encryption/decryption of data blocks, and (iii) data block versioning and mapping to hardware monotonic counters. 
To fill this gap, we designed a \textit{secure storage system} that achieves all our intended security properties for protecting data on untrusted drives ($\S$~\ref{subsec:design-storage}).
\fi

\myparagraph{\#2: Policy compliance} In \project{}, our approach to providing proof of policy compliance is twofold. First, we need to offer guarantees of full integrity and authenticity of all the components of \project{}'s TCB, which includes the host engine, the storage engine, and the trusted monitor. This guarantees the integrity of all the protocols responsible for policy enforcement and query processing. Second, we need to tie that proof of integrity and authenticity to each specific query. Only then we can offer guarantee that each specific query has been processed in a fully compliant manner. To achieve this goal, our starting point is to leverage the remote attestation primitives (see $\S$~\ref{sec:buildingblocks}) available on the core components of \project{}'s infrastructure. However, %we need to overcome two difficulties. First, 
it is necessary to generate consistent attestation quotes across multiple components, i.e., those responsible for evaluating the security policy---the monitor---and those responsible for processing the query--- host and storage engine. Achieving this goal is prone to security flaws, especially if we consider a cloud environment, where migration across servers occurs often, % for server consolidation and fault-tolerance purposes, 
and multiple software versions and hardware generations co-exist. A second hurdle is due to an incompatibility between attestation mechanisms provided by TEE technologies. With SGX relying on IAS~\cite{ias, ananti-hasp-2013}, and TrustZone relying on customized remote attestation protocols implemented by secure world firmware and on manufacturer-dependent platform keys. %In short, the problem is then how to design a robust policy compliance infrastructure that can create reliable proofs of compliance while coping with the dynamism and heterogeneity of typical cloud environments. 
Our proposed solution %to these problems 
is a \textit{policy compliance monitor} ($\S$~\ref{subsec:design-trusted-monitor}).

\myparagraph{\#3: Policy specification} In \project{}, we need to provide a declarative language for the specification of policies. These policies will allow data providers and data consumers to express their requirements for the execution of data processing queries (see $\S$~\ref{sec:arch}). At the same time, given the existence of important data protection regulations such as GDPR and CCPA, our policy specification language should be expressive enough to allow for the declaration of meaningful regulatory guidelines. A central difficulty in designing this language is to find a sweet spot between (i) expressiveness power, (ii) readability, and (iii) evaluation performance. Given the extensiveness of GDPR, for example, one temptation is to design a highly-expressive and versatile language that can cover all the corner cases of the law. However, this approach normally leads to complex policies, which tend to be difficult to read and interpret by humans (and thus prone to error), and can incur considerable performance overheads~\cite{mehta-security-2017}. To strike a balance between these trade-offs, we explore a simple, yet flexible-enough way to express policies that can address some of the most important use-case scenarios w.r.t. GDPR compliance. In cases where it is not necessary to enforce data usage policies such as GDPR or CCPA, policy compliance is still necessary. Clients usually verify the authenticity of nodes using attestation protocols, where each node could have its own attestation mechanism. A policy language allows a client to concisely specify the characteristics of the nodes (in terms of firmware and location) and create an execution environment for the processing of queries (see \S~\ref{sec:policylanguage}).
% Our policy language also allows a data owner to specify how their data can and should be used. We use GDPR to show that it is expressive enough to satisfy real world constraints.} 
%  to enable clients to specify and ensure that their query execution environments are secure and cannot be tampered with. Usually clients rely on remote attestation to verify the authenticity of the hardware and software that is responsible for processing their queries. A policy language helps the client to specify the execution environment concisely without having to worry about the heterogeneity in the attestation mechanisms.} 
 Our proposed solution is a \textit{declarative policy specification language}  ($\S$~\ref{sec:policylanguage}) that is expressive enough to satisfy real-world deployment constraints.



\if0

%% Pramod's brain dump

\myparagraph{\#1: Heterogenous TEEs}

- NDP requires ensuring all security properties are preserved for computation and data across the two heterogenous domains.


- TEEs provide a useful primitive to build a secure NDP architecture. Possibly, state explicitly that we rely on the correct implementation of the abstraction by the hardware.

- However, given different heterogenous ISA domains: SGX and Trustzone. It's not straightforware because the two heterogenous TEEs provide fundamental different abstractions and security properties. 

- (A note we should use technical terms to describe the architecture.)
 
- SGX: provides isolated memory region, where the underlying hardware ensure computing on encrypted memory regions (enclave), where the MEE ensures that enclave (code and data) is secured: confidentiality, integrity and freshness is preserved by the hardware.

- Trustzone: Doesn't provide the same abstraction (normal mode and secure world  with SMC to switch the worlds). Normal world doesn't provide secure memory region, and relies on a secure boot to ensure trusted computing. Whereas, the secure world provides a limited memory region protected by the hardware, but insufficent to do enclave like computing -- at the best, can be used to do keymanagement, secret management.


- {\bf problem \#1: how to build a shielded execution framework or confidential computing framework that address the disparity of these two architectural domains and provide a meaningful framework for the NDP setting. }


-- Hint towards solution: a heterogenous shielded execution framwork, which achieves these properties -- forward pointer to 4.1


\myparagraph{\#2: Untrusted storage medium}


- A secure NDP architecture need to manage both computation and "data at rest" -- usually stored in the untrusted SSDs.


-- TEEs (SGX or ARM Trustzone) provide security properties for the in-memory computation. That's they protect only volatile state in the memory: computation state, code and data.

--- How the trust from the TEEs don't naturally extend to the untrusted storage medium (SSD). 

--- We need to ensure the security properties of the data in the NDP architecture are preserved in stateful settings: that is the security is preserved across system reboot, crash, shutdown or migration. 

--- {\bf problem \# 2: how to extend the trust from heterogenous TEEs (part 1) to the untrusted storage medium to ensure that the security properties are preseved for the data in stateful settings, i.e., across system reboot, crash, migration,etc? }

-- Hint towards solution: a secure storage system, which achieves these properties -- forward pointer to 4.2


\myparagraph{\#3: Policy compliance}


-- A secure NDP architecture need to ensure the computation/data: query execution and data access/accounting follow user-specified execution policy.

-- Policy compliance is challenging in the NDP setting, as a strawman design would require client to ensure the execution is policy compliant individually across the host (x86), storage device/server (ARM), the interconnect, and storage medium (SSD) while data is accessed (read/written). 

-- This strawman design is challenging: error-prone, cumbersome for an end user, but also importantly the TEEs on which we build a policy compliance framework provide fundamental different attestation mechanisms. SGX relies on IAS, and Trustzone relies on XX.

-- Furthermore, the policy compliance is cumbersome as the user needs to ensure that policy compliance is preserved in cloud environment, where the NDP architecture needs to be migrated for server consolidation and fault-tolerance. 

-- Also, the cloud provider may not want to expose the architecture details to the client directly -- excalibur storyline.

--- {\bf problem \# 3: how to provide a unified interface for the clients for policy compliance which will preserve the execution policies across heterogenous execution domains, and provide an transparent abstraction that preserve these properties in the cloud enviroments.}


-- Hint towards solution: a trusted  monitor, which achieves these properties -- forward pointer to 4.3

\fi

